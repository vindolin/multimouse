<!DOCTYPE html>
<html>
<head>
<title>Multimouse</title>
<style>

body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: rgb(164, 164, 240);
}

.cursor {
    transition: opacity 1s, left 50ms, top 50ms;
    transition: scale 500ms ease-out;
    transform-origin: 3px 3px;
    position: absolute;
    opacity: 0;
    animation: cursor-rotation 2s infinite ease-in-out;
    scale: 100;
}

#cursor-self {
    transform-origin: 3px 3px;
    position: absolute;
    animation: cursor-rotation 2s infinite ease-in-out;
    width: 160px;
    height: 160px;
    z-index: 1000;
}

@keyframes cursor-rotation {
    0% {
        transform: rotate(-10deg);
    }
    50% {
        transform: rotate(0deg);
    }
    100% {
        transform: rotate(-10deg);
    }
}

</style>
</head>
<body>
<img src="cursor_self.png" id="cursor-self">
<script>
(() => {
// todo fix cursors not working if server restarts too quickly

// set body background color to random hue
document.body.style.backgroundColor = `hsl(${Math.random() * 360}, 50%, 80%)`;

const pingIntervalTime = 30 * 1000; // ms
const loc = window.location;
const scheme = loc.protocol === 'https:' ? 'wss :' : 'ws:';

const inactiveCursorLifeTime = 2000;
const cursorCleanupIntervalTime = 2000;
const fastReconnectInterval = 1000;

let lastPingTimestamp = Date.now();
let pingInterval;
let cursors = {};
let lastReceived = {};
let cursorCleanupInterval;
let connecting = false;

function registerWebsocketHandlers(ws) {

    // periodically check if we have received a ping in the last n seconds
    console.log('Registering websocket handlers');

    // clear previous ping interval
    clearInterval(pingInterval);

    // and start a new one
    pingInterval = setInterval(() => {
        console.info('Checking ping')
        console.debug('Last ping', Date.now() - lastPingTimestamp, pingIntervalTime);
        if (Date.now() - lastPingTimestamp > pingIntervalTime) {
            console.error('No ping received in the last 30 seconds. Closing socket');
            ws.close();
        }
        // if we are not connected, try to reconnect
        if (ws.readyState !== ws.OPEN) {
            console.error('Socket is not open. Reconnecting');
            connect();
        }
    }, pingIntervalTime / 2);

    ws.onmessage = (event) => {
        console.debug('received message', event.data)

        // check if message is a ping
        if (event.data.startsWith('ping')) {
            console.info('Received ping');
            lastPingTimestamp = Date.now();
            return;
        }

        var data = JSON.parse(event.data);

        if (data.clientId != clientId) { // Don't show our own cursor
            // Convert the scaled coordinates back to pixel coordinates
            var x = data.x * window.innerWidth;
            var y = data.y * window.innerHeight;

            // If we haven't seen this client before, or if this cursor has been removed due to inactivity
            if (! cursors[data.clientId]) {
                console.info('Creating new cursor', data.clientId);

                var cursor = document.createElement('img');
                cursor.classList.add('cursor');
                cursor.src = 'cursor.png';  // Path to the cursor image
                cursor.style.filter = `hue-rotate(${Math.floor(Math.random() * 360)}deg)`;
                cursor.style.left = Math.random() * window.innerWidth + 'px';
                cursor.style.top = Math.random() * window.innerHeight + 'px';

                document.body.appendChild(cursor);
                cursors[data.clientId] = cursor;

                // Fade in the cursor
                setTimeout(() => {
                    cursor.style.opacity = '0.9';
                    cursor.style.scale = '0.5';
                });
            } else {
                console.info('Cursor already exists');
            }

            // Update the position of the image element
            var cursor = cursors[data.clientId];
            cursor.style.left = x + 'px';
            cursor.style.top = y + 'px';

            // Update the last received time for this client
            lastReceived[data.clientId] = Date.now();
        } else {
            console.info('Received our own cursor');
        }
    };

    ws.onclose = (event) => {
        console.info('Socket is closed. Reconnecting in 1 second');

        // fast reconnect
        setTimeout(() => {
            connect();
        }, fastReconnectInterval);
    };

    ws.onerror = (err) => {
        console.info(`Socket error: ${err.message}, Closing socket`);
        ws.close();
        connecting = false;
    };

    ws.onopen = function() {
        console.info('Socket connected');
        connecting = false;
    };
}

var cleanupRunning = false;

var lastMouseCoords = {x: 0, y: 0};

function sendMouseCoords(event, ws) {
    document.getElementById('cursor-self').style.left = event.clientX + 'px';
    document.getElementById('cursor-self').style.top = event.clientY + 'px';

    const x = event.clientX / window.innerWidth;
    const y = event.clientY / window.innerHeight;

    if (x === lastMouseCoords.x && y === lastMouseCoords.y) return;

    // send mouse move event to server
    const msg = JSON.stringify({clientId, x, y});
    console.debug(`Sending mouse move event: ${msg}`);

    try {
        ws.send(msg);
    } catch (e) {
        // console.error('Error sending mouse move event', e);
    }
}

let mouseMoveHandler = null;

// connect to the websocket
function connect() {
    if(connecting) {
        console.info('Already connecting');
        return;
    }

    connecting = true;
    clientId = Date.now() + Math.floor(Math.random() * 100);
    console.info(`Client ${clientId} Connecting to websocket`);
    const ws = new WebSocket(`${scheme}//${loc.host}/ws`);

    registerWebsocketHandlers(ws);

   // clear last mousemove listener
    if (mouseMoveHandler) {
        document.removeEventListener('mousemove', mouseMoveHandler, {passive: true,});
    }

    mouseMoveHandler = (event) => sendMouseCoords(event, ws);
    document.addEventListener('mousemove', mouseMoveHandler, {passive: true,});
}

function removeCursor(clientId) {
    var cursor = cursors[clientId];
    if (cursor) {

        cursor.style.transition = `opacity 1000ms, scale 1000ms`;
        cursor.style.opacity = '0';
        cursor.style.scale = '0';

        cursor.addEventListener('transitionend', () => {
            cursor.remove();
        });

        delete cursors[clientId];
        delete lastReceived[clientId];
    }
}

// Periodically check for inactive clients
setInterval(() => {
    var now = Date.now();
    for (var clientId in lastReceived) {
        // If more than n seconds have passed since the last time we received data from this client
        if (now - lastReceived[clientId] > inactiveCursorLifeTime) {
            removeCursor(clientId);
        }
    }
}, cursorCleanupIntervalTime);  // Check every second

connect();

// lets party!

})();
</script>
</body>
</html>
