<!DOCTYPE html>
<html>
<head>
    <title>Multimouse</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
<script>
(() => {

// todo fix cursors not working if server restarts too quickly

const pingIntervalTime = 30 * 1000; // ms
const loc = window.location;
const scheme = loc.protocol === 'https:' ? 'wss :' : 'ws:';

const cursorLifeTime = 2000;
const cursorCleanupIntervalTime = 2000;
const cursorFadeOutDuration = 1000;
const fastReconnectInterval = 1000;

let lastPingTimestamp = Date.now();
let pingInterval;
let reconnecting;

var cursors = {};
var lastReceived = {};
var mouseMoveHandler;
var cursorCleanupInterval;


function registerWebsocketHandlers(ws) {
    ws.onmessage = (event) => {
        // check if message is a ping
        if(event.data.startsWith('ping')) {
            lastPingTimestamp = Date.now();
            return;
        }

        var data = JSON.parse(event.data);

        // Convert the scaled coordinates back to pixel coordinates
        var x = data.x * window.innerWidth;
        var y = data.y * window.innerHeight;

        if(data.clientId != clientId) { // Don't show our own cursor

            // If we haven't seen this client before, or if this cursor has been removed due to inactivity
            if (! cursors[data.clientId]) {
                var hueRotation = Math.floor(Math.random() * 360);

                var cursor = document.createElement('img');
                cursor.classList.add('cursor');
                cursor.src = 'cursor.png';  // Path to the cursor image
                cursor.style.position = 'absolute';
                cursor.style.filter = 'hue-rotate(' + hueRotation + 'deg)';
                cursor.style.opacity = '0';  // Initially hidden
                cursor.style.transition = 'opacity 1s';
                // img.style.transition = 'transform 500ms';

                document.body.appendChild(cursor);
                cursors[data.clientId] = cursor;

                // Fade in the cursor
                setTimeout(() => {
                    cursor.style.opacity = '1';
                }, 0);
            }

            // Update the position of the image element
            var cursor = cursors[data.clientId];
            cursor.style.left = x + 'px';
            cursor.style.top = y + 'px';

            // Update the last received time for this client
            lastReceived[data.clientId] = Date.now();
        }
    };

    ws.onclose = (event) => {
        console.info('Socket is closed. Reconnecting in 1 second');

        if(reconnecting) return;
        reconnecting = true;

        // fast reconnect
        setTimeout(() => {
            clearInterval(pingInterval);
            connect();
            reconnecting = false;
        }, fastReconnectInterval);
    };

    ws.onerror = (err) => {
        console.error(`Socket error: ${err.message}, Closing socket`);
        ws.close();
    };

    ws.onopen = function() {
        console.info('Socket connected');
    };
}

var cleanupRunning = false;

function cleanupOldCursors() {
    // remove all .cursor elements
    var oldCursors = document.getElementsByClassName('cursor');
    // iterate over oldCursors
    for(const cursor of oldCursors) {
        // remove the cursor
        cursor.remove();

        if(0) {
            cursor.style.transition = 'opacity 1s';
            cursor.style.opacity = '0';

            cursor.addEventListener('transitionend', () => {
                cursor.parentNode.removeChild(cursor);
            });
        }
    }
}

// connect to the websocket
function connect() {
    //cleanupOldCursors();
    clientId = Date.now();
    console.info('Connecting to websocket');
    const ws = new WebSocket(`${scheme}//${loc.host}/ws`);

    registerWebsocketHandlers(ws);

    // periodically check if we have received a ping in the last n seconds
    pingInterval = setInterval(() => {
        if (Date.now() - lastPingTimestamp <= pingIntervalTime) return;
        console.info(`No ping received for more than ${seconds / 1000} seconds!`);
        lastPingTimestamp = Date.now();
        connect();
    }, pingIntervalTime / 2);

    removeEventListener('mousemove', mouseMoveHandler);
    var mouseMoveHandler = document.addEventListener('mousemove', (event) => {
        const x = event.clientX / window.innerWidth;
        const y = event.clientY / window.innerHeight;

        // send mouse move event to server
        const msg = JSON.stringify({clientId, x, y});
        // console.info(`Sending mouse move event: ${msg}`);
        try {ws.send(msg);} catch (e) {}
    });
}


function removeCursor(cursor) {
    cursor.style.transition = `opacity ${cursorFadeOutDuration}ms`;
    cursor.style.opacity = '0';

    cursor.addEventListener('transitionend', () => {
        cursor.remove();
    });
}

function removeStaleCursor(clientId) {
    var cursor = cursors[clientId];
    if (cursor) {
        removeCursor(cursor);
        delete cursors[clientId];
        delete lastReceived[clientId];
    }
}

// Periodically check for inactive clients
setInterval(() => {
    var now = Date.now();
    for (var clientId in lastReceived) {
        // If more than n seconds have passed since the last time we received data from this client
        if (now - lastReceived[clientId] > cursorLifeTime) {
            removeStaleCursor(clientId);
        }
    }
}, cursorCleanupIntervalTime);  // Check every second

// lets party!
connect();

})();
</script>
</body>
</html>
